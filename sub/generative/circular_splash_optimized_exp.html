<html>
	<head>
		<title>Circular Splash Optimized</title>
		<style type="text/css">
			body{margin:0;}
			canvas{width:100%;height:100%}
		</style>
	</head>
	<body>
	<script id="computeShaderPosition" type="x-shader/x-fragment">
	            #define delta (1.0 / 60.0)
							uniform vec2 mouse;
	            void main(){
	                vec2 uv = gl_FragCoord.xy / resolution.xy;
	                vec4 tmpPos = texture2D(texturePosition, uv);
	                vec2 pos = tmpPos.xy;
	                vec2 vel = tmpPos.zw;
									vec2 range = normalize(mouse - pos) * 4.0;
									vel += range;
	                pos += normalize(vel) * 0.07;
	                gl_FragColor = vec4(pos, vel);
	            }
	  </script>
		<script id="particleVertexShader" type="x-shader/x-vertex">
            uniform sampler2D texturePosition;
						varying vec2 vUv;
            void main(){
							  vUv = uv;
                gl_PointSize = 0.999999;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(texture2D(texturePosition, uv).xy, 0.0, 1.0);
            }
    </script>
		<script id="particleFragmentShader" type="x-shader/x-fragment">
		        uniform sampler2D texturePosition;
						varying vec2 vUv;
            void main(){
							  vec4 velTemp = texture2D(texturePosition, vUv);
							  vec2 vel = velTemp.zw;
								float vNorm = length(vel);
								float blightness = sqrt(1.0-vNorm);
                gl_FragColor = vec4(blightness, blightness, blightness, 1.0);
            }
    </script>
		<script type="application/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r83/three.min.js"></script>
		<script type="application/javascript" src="js/three.js/Renderer/GPUComputationRenderer.js"></script>
		<script type="application/javascript">
			window.onload = function(){

				const WIDTH = 200, PARTICLES = WIDTH * WIDTH;

				//WebGLレンダラに関係する変数の宣言
				var scene = new THREE.Scene(),
				camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000),
				mouseX = window.innerWidth/2, mouseY = window.innerHeight/2,
				webGLRenderer = new THREE.WebGLRenderer();
  			webGLRenderer.setClearColor(new THREE.Color(0x000000));

				//GPU計算レンダラに関係する変数の宣言
				var gpuComputationRenderer = new GPUComputationRenderer(WIDTH, WIDTH, webGLRenderer),
				particleUniforms = {
					texturePosition: { value: null }
				};

				//パーティクルシステムの初期値を設定

				var dtPosition = gpuComputationRenderer.createTexture();

				function fillTextures(texturePosition){
					var posArray = texturePosition.image.data;
					for(var k = 0, kl = posArray.length; k < kl; k += 4){
							var x = 0, y = 0;
							posArray[ k + 0 ] = x;
							posArray[ k + 1 ] = y;
							posArray[ k + 2 ] = Math.random()*2-1;
							posArray[ k + 3 ] = Math.random()*2-1;
					}
				}
				fillTextures(dtPosition);

				//GPU計算レンダラに初期値を渡す

      	var positionVariable = gpuComputationRenderer.addVariable( "texturePosition", document.getElementById( 'computeShaderPosition' ).textContent, dtPosition );
				positionVariable.material.uniforms.mouse = { value: [(2*mouseX-window.innerWidth)/window.innerWidth,(window.innerHeight-2*mouseY)/window.innerHeight] };
				gpuComputationRenderer.setVariableDependencies(positionVariable, [positionVariable]);

				//GPU計算レンダラの初期化を実行
				var error = gpuComputationRenderer.init();
				if ( error !== null ) {
					console.error( error );
				}

				//パーティクルの位置に関する初期化

		    function initPosition(){

		        var positions = new Float32Array( PARTICLES * 3 ),
		        p = 0;
		        for ( var i = 0; i < PARTICLES; i++ ) {
		            positions[ p++ ] = 0;
		            positions[ p++ ] = 0;
		            positions[ p++ ] = 0;
		        }

		        var uvs = new Float32Array( PARTICLES * 2 );
		        p = 0;
		        for ( var j = 0; j < WIDTH; j++ ) {
		            for ( var i = 0; i < WIDTH; i++ ) {
		                uvs[ p++ ] = i / ( WIDTH - 1 );
		                uvs[ p++ ] = j / ( WIDTH - 1 );
		            }
		        }

            var geometry = new THREE.BufferGeometry();
		        geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
		        geometry.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));

		        var material = new THREE.ShaderMaterial({
		            uniforms:       particleUniforms,
		            vertexShader:   document.getElementById('particleVertexShader').textContent,
		            fragmentShader: document.getElementById('particleFragmentShader').textContent
		        });
		        material.extensions.drawBuffers = true;

		        var particles = new THREE.Points(geometry, material);
		        particles.matrixAutoUpdate = false;
		        particles.updateMatrix();

		        scene.add(particles);
		    }
				initPosition();

				//カメラの位置を設定

				camera.position.x = 0;
				camera.position.y = 0;
				camera.position.z = 5;

				//ウィンドウリサイズイベントへの対処

				window.onresize = function(){
					webGLRenderer.setSize(window.innerWidth, window.innerHeight);
					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();
				};
				window.onresize();

				window.onmousemove = function(event){
					mouseX = event.clientX;
					mouseY = event.clientY;
					positionVariable.material.uniforms.mouse = { value: [(2*mouseX-window.innerWidth)/window.innerWidth,(window.innerHeight-2*mouseY)/window.innerHeight] };
				}

				//レンダリング結果を表示するDOM要素をドキュメント要素内に追加

				document.body.appendChild(webGLRenderer.domElement);

				//レンダリング実行

				function render(){
					requestAnimationFrame(render);
					gpuComputationRenderer.compute();
					particleUniforms.texturePosition.value = gpuComputationRenderer.getCurrentRenderTarget( positionVariable ).texture;
					webGLRenderer.render(scene, camera);
				}
				render();

			};
		</script>
	</body>
</html>
